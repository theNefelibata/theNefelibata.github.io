<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://localhost:4000</id>
    <title>theNefelibata</title>
    <updated>2021-04-04T09:59:13.328Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://localhost:4000"/>
    <link rel="self" href="http://localhost:4000/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>http://localhost:4000/images/avatar.png</logo>
    <icon>http://localhost:4000/favicon.ico</icon>
    <rights>All rights reserved 2021, theNefelibata</rights>
    <entry>
        <title type="html"><![CDATA[Git基础]]></title>
        <id>http://localhost:4000/post/git-ji-chu/</id>
        <link href="http://localhost:4000/post/git-ji-chu/">
        </link>
        <updated>2021-04-04T09:45:32.000Z</updated>
        <content type="html"><![CDATA[<h2 id="版本管理和git的设计">版本管理和Git的设计</h2>
<h3 id="版本管理的需求">版本管理的需求</h3>
<figure data-type="image" tabindex="1"><img src="http://localhost:4000/post-images/1617529645552.jpg" alt="" loading="lazy"></figure>
<ul>
<li><em><strong>时间机器</strong></em>：
<ul>
<li>全量方案：保存项目的每一个版本的完整信息</li>
<li>增量方案：保存每一版的修改，版本一+补丁=版本二</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">优点</th>
<th style="text-align:center">缺点</th>
<th style="text-align:center">使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">全量方案</td>
<td style="text-align:center">简单、快速</td>
<td style="text-align:center">重复存储，浪费空间</td>
<td style="text-align:center">代码，文本</td>
</tr>
<tr>
<td style="text-align:center">增量方案</td>
<td style="text-align:center">存储空间小</td>
<td style="text-align:center">需要运算，降低了性能，增加了运算时间</td>
<td style="text-align:center">视频，大型二进制文件</td>
</tr>
</tbody>
</table>
<p><img src="http://localhost:4000/post-images/1617529669702.jpg" alt="" loading="lazy"><br>
系统记录了每一个修改版本的完整信息，存储在.git中</p>
<p><em><strong>文件命名</strong></em><br>
使用文件的SHA-1值来命名文件。<br>
<img src="http://localhost:4000/post-images/1617529678048.jpg" alt="" loading="lazy"></p>
<h3 id="tree结构和暂存区">Tree结构和暂存区</h3>
<p><img src="http://localhost:4000/post-images/1617529699670.jpg" alt="" loading="lazy"><br>
<em><strong>目录结构和对应关系</strong></em><br>
<img src="http://localhost:4000/post-images/1617529689632.jpg" alt="" loading="lazy"><br>
Tree是文件夹，blob是二进制文件<br>
<img src="http://localhost:4000/post-images/1617529709801.jpg" alt="" loading="lazy"><br>
<em><strong>暂存区</strong></em><br>
文件状态<br>
<img src="http://localhost:4000/post-images/1617529730491.jpg" alt="" loading="lazy"></p>
<table>
<thead>
<tr>
<th style="text-align:center">code</th>
<th style="text-align:center">index</th>
<th style="text-align:center">SHA-1</th>
<th style="text-align:center">Status</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">在</td>
<td style="text-align:center">在</td>
<td style="text-align:center">不匹配</td>
<td style="text-align:center">modified</td>
</tr>
<tr>
<td style="text-align:center">不存在</td>
<td style="text-align:center">在</td>
<td style="text-align:center"></td>
<td style="text-align:center">removed</td>
</tr>
<tr>
<td style="text-align:center">在</td>
<td style="text-align:center">不存在</td>
<td style="text-align:center"></td>
<td style="text-align:center">added</td>
</tr>
</tbody>
</table>
<h3 id="协同和分支">协同和分支</h3>
<p><em><strong>分布式的版本控制</strong></em><br>
每个人的电脑上都存放一个完整的版本仓库<br>
<em><strong>冲突和合并</strong></em><br>
如果两个人修改了同一个文件File1，第一个人push，没有问题，第二个外人push，会提示File1冲突，需要解决冲突再提交</p>
<p><img src="http://localhost:4000/post-images/1617529758128.jpg" alt="" loading="lazy"><br>
<em><strong>分支</strong></em><br>
<img src="http://localhost:4000/post-images/1617529812308.jpg" alt="" loading="lazy"><br>
<em><strong>合并</strong></em><br>
merge、rebase、cherry-pick</p>
<h2 id="常用git命令">常用Git命令</h2>
<ul>
<li><code>git init</code>
<ul>
<li>git初始化命令</li>
<li>将一个文件夹初始化为git仓库</li>
</ul>
</li>
<li><code>git add filename</code>
<ul>
<li><code>git add ./*</code> 将所有文件添加到暂存区</li>
<li>将filename文件添加到暂存区</li>
</ul>
</li>
<li><code>git status</code>
<ul>
<li>查看暂存区状态</li>
</ul>
</li>
<li><code>git reset HEAD--a.txt</code>
<ul>
<li>将文件移出暂存区</li>
</ul>
</li>
<li><code>git cat-file -p SHA-1</code>
<ul>
<li>查看SHA-1文件内容</li>
</ul>
</li>
<li><code>git ls-files --stage</code>
<ul>
<li>查看暂存区内容</li>
</ul>
</li>
<li><code>git commit -m ‘ ‘</code>
<ul>
<li>将暂存区文件提交到git仓库</li>
</ul>
</li>
<li><code>git branch name</code>
<ul>
<li>创建一个名为name的分支</li>
</ul>
</li>
<li><code>git checkout name</code>
<ul>
<li>切换到某个分支</li>
<li>回到某个历史分支<code>git checkout SHA-1</code></li>
<li><code>git checkout -b name</code> 创建一个分支并切换到分支</li>
</ul>
</li>
<li><code>git merge branch-name</code>
<ul>
<li>将分支branch-name合并到当前分支</li>
</ul>
</li>
<li>合并失败：
<ul>
<li><code>git merge --abort</code>放弃合并</li>
<li>手动解决冲突后再提交，然后合并</li>
</ul>
</li>
<li><code>git log</code>
<ul>
<li>查看git日志</li>
</ul>
</li>
<li><code>git pull (origin main)</code>
<ul>
<li>将远程仓库的内容合并到本地仓库</li>
</ul>
</li>
<li><code>git push</code>
<ul>
<li>将本地仓库的内容push到远程仓库</li>
</ul>
</li>
<li><code>git stash</code>
<ul>
<li>将当前修改放入一个列表
<ul>
<li><code>git stash list</code></li>
<li><code>git stash apply</code></li>
</ul>
</li>
<li><code>git stash show/drop/clear</code></li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode 森林中的兔子]]></title>
        <id>http://localhost:4000/post/leetcode-sen-lin-zhong-de-tu-zi/</id>
        <link href="http://localhost:4000/post/leetcode-sen-lin-zhong-de-tu-zi/">
        </link>
        <updated>2021-04-03T17:55:34.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2>
<p>森林中，每个兔子都有颜色。其中一些兔子（可能是全部）告诉你还有多少其他的兔子和自己有相同的颜色。我们将这些回答放在 answers 数组里。</p>
<p>返回森林中兔子的最少数量。</p>
<pre><code>示例:
输入: answers = [1, 1, 2]
输出: 5
解释:
两只回答了 &quot;1&quot; 的兔子可能有相同的颜色，设为红色。
之后回答了 &quot;2&quot; 的兔子不会是红色，否则他们的回答会相互矛盾。
设回答了 &quot;2&quot; 的兔子为蓝色。
此外，森林中还应有另外 2 只蓝色兔子的回答没有包含在数组中。
因此森林中兔子的最少数量是 5: 3 只回答的和 2 只没有回答的。

输入: answers = [10, 10, 10]
输出: 11

输入: answers = []
输出: 0
</code></pre>
<h2 id="题解">题解</h2>
<p>某种颜色的兔子数等于那种颜色兔子的回答数+1，颜色相同的兔子的回答一定相同，基于这两个特征，我们要求最少的兔子数量，我们可以认为回答相同的兔子属于一种颜色，此时我们只需统计出回答相同的兔子的数量，分配颜色即可，示意图如下：<br>
<img src="http://localhost:4000/post-images/1617472566346.jpg" alt="" loading="lazy"></p>
<h2 id="代码">代码</h2>
<pre><code class="language-python">class Solution:
	def numRabbits(self, answers: List[int]) -&gt; int:
	cnt = {}
	ans = 0
	for i in answers:
		if i not in cnt.keys():
			cnt[i] = 1
		else:
			cnt[i] += 1
	for k, v in cnt.items():
		ans += (v // (k+1)) * (k + 1)
		if (v % (k+1)) != 0 :
			ans += k + 1

	return ans
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode 最长公共子序列]]></title>
        <id>http://localhost:4000/post/leetcode-zui-chang-gong-gong-zi-xu-lie/</id>
        <link href="http://localhost:4000/post/leetcode-zui-chang-gong-gong-zi-xu-lie/">
        </link>
        <updated>2021-04-03T14:29:33.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h2 id="题目描述">题目描述</h2>
<p>给定两个字符串 text1   和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。<br>
一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>
例如，&quot;ace&quot; 是 &quot;abcde&quot; 的子序列，但 &quot;aec&quot; 不是 &quot;abcde&quot; 的子序列。<br>
两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p>
<h2 id="题解">题解</h2>
<p>这是一道典型的线性规划，定义数组dp[i][j] 为text1[0:i]和text2[0:j]最长公共子序列的长度。</p>
<ul>
<li>如果text1[i] == text2[j]，那么dp[i][j]就是dp[i-1][j-1]+1</li>
<li>如果text1[i] != text2[j]，那么dp[i][j]就是text1[0:i]和text2[0:j-1]的最长公共子序列 和 text1[0:i-1]和text2[0:j]的最长公共子序列 中最大的那个。</li>
</ul>
<figure data-type="image" tabindex="1"><img src="http://localhost:4000/post-images/1617460209274.jpg" alt="" loading="lazy"></figure>
<h2 id="代码">代码</h2>
<pre><code class="language-python">class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -&gt; int:
        m = len(text1)
        n = len(text2)
        dp = [[0]*(n + 1) for _ in range(m + 1)]

        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if text1[i-1] == text2[j-1]:
                    dp[i][j] = dp[i-1][j-1] + 1
                else:
                    dp[i][j] = max(dp[i][j-1], dp[i-1][j])
            
        return dp[m][n]
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java基础]]></title>
        <id>http://localhost:4000/post/java-ji-chu/</id>
        <link href="http://localhost:4000/post/java-ji-chu/">
        </link>
        <updated>2021-03-02T08:08:37.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="stastic-关键字">Stastic 关键字</h1>
<p>类是对象的外观及行为方式的描述。通常只有在使用 new 创建那个类的对象后，数据存储空间才被分配，对象的方法才能供外界调用。这种方式在两种情况下是不足的。</p>
<ul>
<li>
<p>有时你只想为特定字段（注：也称为属性、域）分配一个共享存储空间，而不去考虑究竟要创建多少对象，甚至根本就不创建对象。</p>
</li>
<li>
<p>创建一个与此类的任何对象无关的方法。也就是说，即使没有创建对象，也能调用该方法。<br>
我们可以在类的字段或方法前添加 static 关键字来表示这是一个静态字段或静态方法。 代码示例：</p>
<pre><code class="language-java">    class StaticTest {
        static int i = 47;
        }
</code></pre>
<p>现在即使创建两个<code>StaticTest</code>对象，每个对象的变量<code>i</code>值相同，共享存储空间:</p>
<pre><code class="language-java">  StaticTest st1 = new StaticTest()
  StaticTest st2 = new StaticTest()
  st1.i = 47
  st2.i = 47
  st1.i++
  st2.i = 48
</code></pre>
<p>或者我们可以直接调用<code>StaticTest.i++</code>，效果一样。<br>
使用类名直接引用静态变量是首选方法，因为它强调了变量的静态属性。类似的逻辑也适用于静态方法。我们可以通过对象引用静态方法，就像使用任何方法一样，也可以通过特殊的语法方式 <code>Classname.method()</code>来直接调用静态字段或方法，代码示例：</p>
<pre><code class="language-java">  class Incrementable {
  static void increment() { 
    StaticTest.i++; 
      }
  }
</code></pre>
<p>可以先将<code>Incrementable</code>实例化后再调用<code>Incrementable.increment()</code>，当然，更简便的方法是直接调用<code>Incrementable.increment()</code></p>
</li>
</ul>
<h1 id="构造器">构造器</h1>
<p>构造方法是与类名相同的类方法，在实例化类的过程中会首先调用构造器进行初始化。</p>
<pre><code class="language-java">class Rock2 {
    Rock2(int i) {
        System.out.print(&quot;Rock &quot; + i + &quot; &quot;);
    }
}

public class SimpleConstructor2 {
    public static void main(String[] args) {
        for (int i = 0; i &lt; 8; i++) {
            new Rock2(i);
        }
    }
}
</code></pre>
<p>输出：</p>
<pre><code class="language-java">Rock 0 Rock 1 Rock 2 Rock 3 Rock 4 Rock 5 Rock 6 Rock 7
</code></pre>
<p>构造器没有返回值，它是一种特殊的方法。</p>
<h1 id="方法重载">方法重载</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[对象的概念]]></title>
        <id>http://localhost:4000/post/dui-xiang-de-gai-nian/</id>
        <link href="http://localhost:4000/post/dui-xiang-de-gai-nian/">
        </link>
        <updated>2021-03-02T06:07:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="抽象">抽象</h2>
<ol>
<li><strong>万物皆对象</strong>。你可以将对象想象成一种特殊的变量。它存储数据，但可以在你对其“发出请求”时执行本身的操作。理论上讲，你总是可以从要解决的问题身上抽象出概念性的组件，然后在程序中将其表示为一个对象。</li>
<li><strong>程序是一组对象，通过消息传递来告知彼此该做什么</strong>。要请求调用一个对象的方法，你需要向该对象发送消息。</li>
<li><strong>每个对象都有自己的存储空间，可容纳其他对象</strong>。或者说，通过封装现有对象，可制作出新型对象。所以，尽管对象的概念非常简单，但在程序中却可达到任意高的复杂程度。</li>
<li><strong>每个对象都有一种类型</strong>。根据语法，每个对象都是某个“类”的一个“实例”。其中，“类”（Class）是“类型”（Type）的同义词。一个类最重要的特征就是“能将什么消息发给它？”。</li>
<li><strong>同一类所有对象都能接收相同的消息</strong>。这实际是别有含义的一种说法，大家不久便能理解。由于类型为“圆”（Circle）的一个对象也属于类型为“形状”（Shape）的一个对象，所以一个圆完全能接收发送给&quot;形状”的消息。这意味着可让程序代码统一指挥“形状”，令其自动控制所有符合“形状”描述的对象，其中自然包括“圆”。这一特性称为对象的“可替换性”，是OOP最重要的概念之一。</li>
</ol>
<h2 id="封装">封装</h2>
<p>研发程序员开发一个工具类，该工具类仅向应用程序员公开必要的内容，并隐藏内部实现的细节。这样可以有效地避免该工具类被错误的使用和更改，从而减少程序出错的可能。彼此职责划分清晰，相互协作。Java 有三个显式关键字来设置类中的访问权限：<code>public</code>（公开），<code>private</code>（私有）和<code>protected</code>（受保护）。这些访问修饰符决定了谁能使用它们修饰的方法、变量或类。</p>
<ul>
<li>
<p><code>public</code>（公开）表示任何人都可以访问和使用该元素；</p>
</li>
<li>
<p><code>private</code>（私有）除了类本身和类内部的方法，外界无法直接访问该元素。private 是类和调用者之间的屏障。任何试图访问私有成员的行为都会报编译时错误；</p>
</li>
<li>
<p><code>protected</code>（受保护）类似于 private，区别是子类（下一节就会引入继承的概念）可以访问 protected 的成员，但不能访问 private 成员；</p>
</li>
<li>
<p><code>default</code>（默认）如果你不使用前面的三者，默认就是 default 访问权限。default 被称为包访问，因为该权限下的资源可以被同一包（库组件）中其他类的成员访问。</p>
</li>
</ul>
<h2 id="复用">复用</h2>
]]></content>
    </entry>
</feed>